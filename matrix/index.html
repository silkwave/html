<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>행렬 연산기 (Matrix Calculator)</title>
  <style>
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
      margin: 24px;
      color: #111;
      background: #f7f8fb;
    }
    h1 { margin-bottom: 8px; font-size: 1.4rem; }
    .wrapper { display: grid; grid-template-columns: 1fr 1fr; gap: 18px; align-items: start; }
    .card {
      background: white;
      border-radius: 10px;
      padding: 14px;
      box-shadow: 0 6px 18px rgba(20,20,50,0.06);
      border: 1px solid rgba(0,0,0,0.04);
    }
    label { display:block; font-size:0.9rem; margin-bottom:6px; }
    .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
    input[type="number"] { width:64px; padding:6px 8px; border-radius:6px; border:1px solid #ddd; }
    button {
      background:#2f80ed; color:white; border:0; padding:8px 10px; border-radius:7px; cursor:pointer;
      font-weight:600;
    }
    button.secondary { background:#555; }
    button.ghost { background: transparent; color:#2f80ed; border:1px solid #cfe3ff; }
    .matrix-grid { display:inline-grid; gap:6px; padding:8px; background:#fbfdff; border-radius:8px; }
    .matrix-grid input { width:56px; padding:6px; text-align:center; border:1px solid #e6eefc; border-radius:6px; }
    .matrix-title { font-weight:700; margin-bottom:6px; }
    .result { white-space:pre; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; background:#0f1724; color:#dbeafe; padding:12px; border-radius:8px; }
    .row { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    small.hint { color:#666; display:block; margin-top:6px; }
    @media (max-width:800px) {
      .wrapper { grid-template-columns: 1fr; }
      .matrix-grid input { width:48px; }
    }
  </style>
</head>
<body>
  <h1>행렬 연산기 — JavaScript (덧셈 · 곱셈 · 전치)</h1>

  <div class="wrapper">
    <div class="card" id="left">
      <div class="matrix-title">행렬 A</div>
      <div class="row controls">
        <label>행:
          <input id="a-rows" type="number" min="1" value="2" />
        </label>
        <label>열:
          <input id="a-cols" type="number" min="1" value="2" />
        </label>
        <button id="genA" class="ghost">생성</button>
        <button id="transA" class="secondary">전치(Aᵀ)</button>
      </div>
      <div id="matrixA" class="matrix-grid"></div>
    </div>

    <div class="card" id="right">
      <div class="matrix-title">행렬 B</div>
      <div class="row controls">
        <label>행:
          <input id="b-rows" type="number" min="1" value="2" />
        </label>
        <label>열:
          <input id="b-cols" type="number" min="1" value="2" />
        </label>
        <button id="genB" class="ghost">생성</button>
        <button id="transB" class="secondary">전치(Bᵀ)</button>
      </div>
      <div id="matrixB" class="matrix-grid"></div>
    </div>

    <div class="card" style="grid-column: 1 / -1;">
      <div class="row" style="gap:12px;">
        <button id="add" >A + B</button>
        <button id="mul" >A × B</button>
        <button id="clear" class="ghost">초기화</button>
        <div style="flex:1"></div>
        <small class="hint">빈 칸은 0으로 취급합니다. 곱셈은 A의 열 수와 B의 행 수가 같아야 합니다.</small>
      </div>

      <div style="margin-top:12px;">
        <div class="matrix-title">결과</div>
        <div id="result" class="result">결과가 여기에 표시됩니다.</div>
      </div>
    </div>
  </div>

  <script>
    // Matrix helper (행렬 연산)
    class Matrix {
      constructor(rows, cols, data = null) {
        this.rows = rows | 0;
        this.cols = cols | 0;
        this.data = data ? data.slice() : new Array(this.rows * this.cols).fill(0);
      }

      index(r, c) { return r * this.cols + c; }

      get(r, c) {
        if (r < 0 || r >= this.rows || c < 0 || c >= this.cols) return 0;
        return Number(this.data[this.index(r,c)]) || 0;
      }

      set(r, c, val) {
        this.data[this.index(r,c)] = Number(val) || 0;
      }

      static fromInputs(containerEl, rows, cols) {
        const m = new Matrix(rows, cols);
        const inputs = containerEl.querySelectorAll('input');
        // assume row-major ordering
        for (let r=0; r<rows; r++) {
          for (let c=0; c<cols; c++) {
            const idx = r*cols + c;
            const val = inputs[idx] ? inputs[idx].value.trim() : "0";
            m.set(r, c, val === "" ? 0 : parseFloat(val));
          }
        }
        return m;
      }

      add(other) {
        if (this.rows !== other.rows || this.cols !== other.cols) {
          throw new Error("행렬 크기가 같아야 덧셈 가능합니다.");
        }
        const out = new Matrix(this.rows, this.cols);
        for (let i=0;i<this.data.length;i++) {
          out.data[i] = Number(this.data[i]) + Number(other.data[i] || 0);
        }
        return out;
      }

      multiply(other) {
        if (this.cols !== other.rows) {
          throw new Error("A의 열 수와 B의 행 수가 같아야 곱셈 가능합니다.");
        }
        const out = new Matrix(this.rows, other.cols);
        for (let r=0; r<out.rows; r++) {
          for (let c=0; c<out.cols; c++) {
            let s = 0;
            for (let k=0; k<this.cols; k++) {
              s += this.get(r,k) * other.get(k,c);
            }
            out.set(r,c,s);
          }
        }
        return out;
      }

      transpose() {
        const out = new Matrix(this.cols, this.rows);
        for (let r=0; r<this.rows; r++) {
          for (let c=0; c<this.cols; c++) {
            out.set(c, r, this.get(r,c));
          }
        }
        return out;
      }

      toString() {
        const lines = [];
        for (let r=0; r<this.rows; r++) {
          const row = [];
          for (let c=0; c<this.cols; c++) {
            let v = this.get(r,c);
            // 숫자 포맷: 정수면 정수 형태로, 아니면 소수점 6자리까지 자름
            if (Number.isInteger(v)) row.push(String(v));
            else row.push(parseFloat(v.toFixed(6)).toString());
          }
          lines.push("[ " + row.join(" , ") + " ]");
        }
        return lines.join("\\n");
      }

      renderAsGrid(container) {
        // clear
        container.innerHTML = "";
        container.style.gridTemplateColumns = `repeat(${this.cols}, auto)`;
        for (let r=0; r<this.rows; r++) {
          for (let c=0; c<this.cols; c++) {
            const input = document.createElement('input');
            input.type = "number";
            input.step = "any";
            input.value = String(this.get(r,c));
            container.appendChild(input);
          }
        }
      }
    }

    // DOM helpers
    const el = id => document.getElementById(id);
    const matrixAEl = el('matrixA');
    const matrixBEl = el('matrixB');
    const resultEl = el('result');

    // 초기 생성
    function genMatrixUI(container, rows, cols, fill=0) {
      container.innerHTML = "";
      container.style.gridTemplateColumns = `repeat(${cols}, auto)`;
      for (let r=0; r<rows; r++) {
        for (let c=0; c<cols; c++) {
          const input = document.createElement('input');
          input.type = "number";
          input.step = "any";
          input.value = fill;
          container.appendChild(input);
        }
      }
    }

    function readMatrixFromUI(container, rows, cols) {
      return Matrix.fromInputs(container, rows, cols);
    }

    // 기본 초기화
    function init() {
      genMatrixUI(matrixAEl, Number(el('a-rows').value), Number(el('a-cols').value), 0);
      genMatrixUI(matrixBEl, Number(el('b-rows').value), Number(el('b-cols').value), 0);
      resultEl.textContent = "결과가 여기에 표시됩니다.";
    }

    // 버튼 바인딩
    el('genA').addEventListener('click', () => {
      const r = Number(el('a-rows').value) || 1;
      const c = Number(el('a-cols').value) || 1;
      genMatrixUI(matrixAEl, r, c, 0);
    });
    el('genB').addEventListener('click', () => {
      const r = Number(el('b-rows').value) || 1;
      const c = Number(el('b-cols').value) || 1;
      genMatrixUI(matrixBEl, r, c, 0);
    });

    el('add').addEventListener('click', () => {
      try {
        const aR = Number(el('a-rows').value), aC = Number(el('a-cols').value);
        const bR = Number(el('b-rows').value), bC = Number(el('b-cols').value);
        const A = readMatrixFromUI(matrixAEl, aR, aC);
        const B = readMatrixFromUI(matrixBEl, bR, bC);
        const R = A.add(B);
        resultEl.textContent = R.toString();
      } catch (e) {
        resultEl.textContent = "오류: " + e.message;
      }
    });

    el('mul').addEventListener('click', () => {
      try {
        const aR = Number(el('a-rows').value), aC = Number(el('a-cols').value);
        const bR = Number(el('b-rows').value), bC = Number(el('b-cols').value);
        const A = readMatrixFromUI(matrixAEl, aR, aC);
        const B = readMatrixFromUI(matrixBEl, bR, bC);
        const R = A.multiply(B);
        resultEl.textContent = R.toString();
      } catch (e) {
        resultEl.textContent = "오류: " + e.message;
      }
    });

    el('transA').addEventListener('click', () => {
      try {
        const aR = Number(el('a-rows').value), aC = Number(el('a-cols').value);
        const A = readMatrixFromUI(matrixAEl, aR, aC);
        const T = A.transpose();
        // 전치 결과를 오른쪽에 덮어쓰지 않고 결과 창에 출력
        resultEl.textContent = T.toString();
      } catch(e) {
        resultEl.textContent = "오류: " + e.message;
      }
    });

    el('transB').addEventListener('click', () => {
      try {
        const bR = Number(el('b-rows').value), bC = Number(el('b-cols').value);
        const B = readMatrixFromUI(matrixBEl, bR, bC);
        const T = B.transpose();
        resultEl.textContent = T.toString();
      } catch(e) {
        resultEl.textContent = "오류: " + e.message;
      }
    });

    el('clear').addEventListener('click', () => {
      el('a-rows').value = 2;
      el('a-cols').value = 2;
      el('b-rows').value = 2;
      el('b-cols').value = 2;
      init();
    });

    // 페이지 로드 시 초기화
    init();

    // 편의: Enter로 마지막 포커스된 input에서 실행하기 (예: Shift+Enter로 곱셈 실행)
    document.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter' && ev.shiftKey) {
        // Shift+Enter -> 곱셈
        ev.preventDefault();
        el('mul').click();
      } else if (ev.key === 'Enter' && ev.ctrlKey) {
        // Ctrl+Enter -> 덧셈
        ev.preventDefault();
        el('add').click();
      }
    });
  </script>
</body>
</html>
