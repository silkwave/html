<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>바둑 - 자살수 + 사활 판정 + 숫자 표시 + Undo + 힌돌 AI + 깜박임</title>
    <style>
      body {
        font-family: sans-serif;
      }
      canvas {
        border: 1px solid black;
        background-color: #f4dfa6;
      }
      #status {
        margin-top: 10px;
        font-size: 18px;
      }
      button {
        margin-top: 10px;
        margin-right: 5px;
        font-size: 16px;
      }
    </style>
  </head>
  <body>
    <h2>바둑 (자살수 금지 + 사활 판정 + 숫자 표시 + Undo + 힌돌 AI + 깜박임)</h2>
    <canvas id="board" width="570" height="570"></canvas>
    <div id="status">흑 차례</div>
    <button onclick="checkLife()">사활 판정</button>
    <button onclick="undo()">Undo</button>
    <button onclick="pass()">패스</button>

    <script>
      const SIZE = 19; 
      const CELL = 30; 
      const OFFSET = CELL; 
      const canvas = document.getElementById("board");
      const ctx = canvas.getContext("2d");
      const status = document.getElementById("status");

      let board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
      let orderBoard = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));

      let currentPlayer = 1; // 흑: 사람, 백: AI
      let moveCount = 0;
      let history = [];

      let passCount = 0; // 연속 패스 체크

      // 깜박임 관련 변수
      let blinkPosition = null;
      let blinkOpacity = 1;
      let blinkIntervalId = null;

      function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < SIZE; i++) {
          ctx.beginPath();
          ctx.moveTo(OFFSET, OFFSET + i * CELL);
          ctx.lineTo(OFFSET + (SIZE - 1) * CELL, OFFSET + i * CELL);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(OFFSET + i * CELL, OFFSET);
          ctx.lineTo(OFFSET + i * CELL, OFFSET + (SIZE - 1) * CELL);
          ctx.stroke();
        }
        const starPoints = [3, 9, 15];
        for (let x of starPoints) {
          for (let y of starPoints) {
            ctx.beginPath();
            ctx.arc(OFFSET + x * CELL, OFFSET + y * CELL, 4, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "16px sans-serif";

        for (let y = 0; y < SIZE; y++) {
          for (let x = 0; x < SIZE; x++) {
            if (board[y][x] !== 0) {
              if (blinkPosition && blinkPosition.x === x && blinkPosition.y === y) {
                ctx.globalAlpha = blinkOpacity;
                drawStone(x, y, board[y][x]);
                ctx.globalAlpha = 1;
              } else {
                drawStone(x, y, board[y][x]);
              }
              const num = orderBoard[y][x];
              if (num > 0) {
                ctx.fillStyle = board[y][x] === 1 ? "white" : "black";
                ctx.fillText(num, OFFSET + x * CELL, OFFSET + y * CELL);
              }
            }
          }
        }
      }

      function drawStone(x, y, player) {
        ctx.beginPath();
        ctx.arc(OFFSET + x * CELL, OFFSET + y * CELL, CELL / 2 - 2, 0, Math.PI * 2);
        ctx.fillStyle = player === 1 ? "black" : "white";
        ctx.fill();
        ctx.stroke();
      }

      function getGroupAndLiberties(x, y) {
        const color = board[y][x];
        let visited = Array.from({ length: SIZE }, () => Array(SIZE).fill(false));
        let group = [];
        let liberties = 0;

        function dfs(cx, cy) {
          if (visited[cy][cx]) return;
          visited[cy][cx] = true;
          group.push([cx, cy]);
          const dirs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
          ];
          for (let [dx, dy] of dirs) {
            const nx = cx + dx;
            const ny = cy + dy;
            if (nx < 0 || ny < 0 || nx >= SIZE || ny >= SIZE) continue;

            if (board[ny][nx] === 0) {
              liberties++;
            } else if (board[ny][nx] === color) {
              dfs(nx, ny);
            }
          }
        }

        dfs(x, y);
        return { group, liberties };
      }

      function getEyesCount(group, color) {
        let eyes = 0;
        let checked = new Set();

        for (let [x, y] of group) {
          const dirs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
          ];
          for (let [dx, dy] of dirs) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx < 0 || ny < 0 || nx >= SIZE || ny >= SIZE) continue;
            if (board[ny][nx] === 0) {
              let key = nx + "," + ny;
              if (!checked.has(key) && isEye(nx, ny, color)) {
                eyes++;
                checked.add(key);
              }
            }
          }
        }
        return eyes;
      }

      function isEye(x, y, color) {
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];
        for (let [dx, dy] of dirs) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= SIZE || ny >= SIZE) return false;
          if (board[ny][nx] !== color) return false;
        }
        return true;
      }

      function removeGroup(group) {
        for (let [x, y] of group) {
          board[y][x] = 0;
          orderBoard[y][x] = 0;
        }
      }

      function handleClick(e) {
        if (currentPlayer !== 1) return;
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const x = Math.round((mx - OFFSET) / CELL);
        const y = Math.round((my - OFFSET) / CELL);
        if (x < 0 || y < 0 || x >= SIZE || y >= SIZE) return;
        if (board[y][x] !== 0) return;

        if (!placeStone(x, y, currentPlayer)) {
          alert("자살수입니다!");
          return;
        }
        passCount = 0;

        startBlink(x, y);

        currentPlayer = 3 - currentPlayer;
        status.textContent = (currentPlayer === 1 ? "흑" : "백") + " 차례";
        drawBoard();

        if (currentPlayer === 2) {
          setTimeout(aiMove, 300);
        }
      }

      function placeStone(x, y, player) {
        board[y][x] = player;
        moveCount++;
        orderBoard[y][x] = moveCount;

        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];
        let captured = false;
        let capturedGroups = [];

        for (let [dx, dy] of dirs) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= SIZE || ny >= SIZE) continue;

          if (board[ny][nx] === 3 - player) {
            const { group, liberties } = getGroupAndLiberties(nx, ny);
            if (liberties === 0) {
              removeGroup(group);
              captured = true;
              capturedGroups.push(group);
            }
          }
        }

        const { liberties } = getGroupAndLiberties(x, y);
        if (!captured && liberties === 0) {
          board[y][x] = 0;
          orderBoard[y][x] = 0;
          moveCount--;
          return false;
        }

        history.push({ x, y, player, capturedGroups, order: moveCount });
        return true;
      }

      function aiMove() {
        let candidates = [];
        for (let y = 0; y < SIZE; y++) {
          for (let x = 0; x < SIZE; x++) {
            if (board[y][x] !== 0) continue;
            board[y][x] = currentPlayer;
            const { liberties } = getGroupAndLiberties(x, y);
            board[y][x] = 0;
            if (liberties > 0) {
              candidates.push([x, y]);
            }
          }
        }

        if (candidates.length === 0) {
          alert("AI도 착수할 곳이 없습니다. 패스합니다.");
          pass();
          return;
        }

        const [x, y] = candidates[Math.floor(Math.random() * candidates.length)];
        placeStone(x, y, currentPlayer);

        startBlink(x, y);

        passCount = 0;
        currentPlayer = 3 - currentPlayer;
        status.textContent = (currentPlayer === 1 ? "흑" : "백") + " 차례";
        drawBoard();
      }

      function undo() {
        if (history.length === 0) {
          alert("더 이상 되돌릴 수 없습니다.");
          return;
        }
        undoOnce();
        undoOnce();
        drawBoard();
      }
      function undoOnce() {
        if (history.length === 0) return;
        const lastMove = history.pop();
        const { x, y, player, capturedGroups, order } = lastMove;
        board[y][x] = 0;
        orderBoard[y][x] = 0;
        moveCount--;
        for (let group of capturedGroups) {
          for (let [gx, gy] of group) {
            board[gy][gx] = 3 - player;
            orderBoard[gy][gx] = 0;
          }
        }
        currentPlayer = player;
        status.textContent = (currentPlayer === 1 ? "흑" : "백") + " 차례";
      }

      function pass() {
        passCount++;
        if (passCount >= 2) {
          alert("두 플레이어 모두 패스했습니다. 게임 종료.");
        } else {
          currentPlayer = 3 - currentPlayer;
          status.textContent = (currentPlayer === 1 ? "흑" : "백") + " 차례";
          if (currentPlayer === 2) {
            setTimeout(aiMove, 300);
          }
        }
      }

      function checkLife() {
        let alive = [];
        let dead = [];

        let visited = Array.from({ length: SIZE }, () =>
          Array(SIZE).fill(false)
        );
        for (let y = 0; y < SIZE; y++) {
          for (let x = 0; x < SIZE; x++) {
            if (board[y][x] !== 0 && !visited[y][x]) {
              const { group } = getGroupAndLiberties(x, y);
              group.forEach(([gx, gy]) => (visited[gy][gx] = true));

              const eyes = getEyesCount(group, board[y][x]);
              if (eyes >= 2) alive.push(group);
              else dead.push(group);
            }
          }
        }

        alert(`살아있는 그룹: ${alive.length}, 죽은 그룹: ${dead.length}`);
      }

      // 깜박임 애니메이션 시작
      function startBlink(x, y) {
        blinkPosition = { x, y };
        blinkOpacity = 1;
        if (blinkIntervalId) clearInterval(blinkIntervalId);

        let fadeOut = true;
        let elapsed = 0;
        const blinkDuration = 500;
        const intervalMs = 50;

        blinkIntervalId = setInterval(() => {
          if (fadeOut) {
            blinkOpacity -= 0.15;
            if (blinkOpacity <= 0.2) {
              blinkOpacity = 0.2;
              fadeOut = false;
            }
          } else {
            blinkOpacity += 0.15;
            if (blinkOpacity >= 1) {
              blinkOpacity = 1;
              fadeOut = true;
            }
          }
          elapsed += intervalMs;
          drawBoard();

          if (elapsed >= blinkDuration) {
            clearInterval(blinkIntervalId);
            blinkIntervalId = null;
            blinkPosition = null;
            drawBoard();
          }
        }, intervalMs);
      }

      canvas.addEventListener("click", handleClick);
      drawBoard();
    </script>
  </body>
</html>
